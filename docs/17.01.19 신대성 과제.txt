- iOS에서 메모리 관리를 어떻게 처리합니까?
c계열 언어의 메모리관리 규칙을 따르는데 쉽게 말해서, 프로그래머가 일일이 alloc으로 할당한 메모리는 반드시 release 해줘야한다.
하지만 alloc으로 생성한 객체가 여기저기 참조되고 다른 객체로 넘겨지고 한다면 일일이 release해주기 번거로워진다.     그렇기 때문에 obj-c에서는 참조수(retain count)를 이용하여 메모리 누수를 해결한다.
alloc으로 처음 생겨났을 때 1의 참조수를 가지게 되고 다른 객체가 참조하게 되면 +1, 더이상 필요하지 않아서 release를 시키면 -1을 시킨다. 결국 0이 되었을 때 해당 객체는 메모리상에서 지워지게 되는 구조이다.
하지만 최신 언어기법에 맞게 obj-c에도 자바의 GC 기능과 같이 프로그래머가 일일이 메모리 할당을 풀어주는 일을 하지 않아도 된다.
ARC(Automatic Reference Counting, xcode4에서 도입)로 인해서 위에서 설명한 참조수에 대해서 프로그래머는 신경쓰지 않아도 된다. ARC의 동작 방법은 컴파일 시점에서 소스 곳곳에 알아서 release 코드를 넣어준다.
컴파일 시점에서 이루어지기 때문에 앱의 퍼포먼스에는 아무런 문제가 없다.


- atomic과 nonatomic 차이점을 설명 할 수 있습니까?
다중 스레드가 해당 프로퍼티를 참조하고 있는 상황에서 어떻게 처리할거냐를 명시해주는 것이다.
만약 두개의 스레드가 동시에 일을 처리하고 있다고 가정했을 때, 두개의 스레드가 같은 프로퍼티를 읽고 한쪽에서 프로퍼티의 값을 변경했다면 문제가 생길 수도 있다.
이 때 필요한게 atomic이다. 두개의 스레드가 같은 프로퍼티를 읽어야 할 상황이 왔을 때, 프로퍼티가 atomic이라면 한쪽 스레드를 잠시 lock을 걸고 참조하고 있는 스레드가 일처리 끝날 때 까지 기다리게 된다.
반대로 nonatomic은 lock을 거는 절차 없이 언제든지 스레드가 프로퍼티를 참조할 수 있다.
스레드의 성능저하가 일어날 수 있기 때문에 obj-c에서는 atomic이 디폴트 값이다.


- weak와 strong의 차이점을 설명 할 수 있습니까?
약한참조, 강한참조를 말한다.
weak(약한참조)는 다른곳에 참조되어도 참조수를 증가시키지 않는다. 따라서 객체가 dealloc되어졌을 때는 참조된 곳에는 nil이 되어버린다.
strong(강한참조)는 weak와 반대로 다른곳에 참조된만큼 참조수를 증가시킨다. 그렇기 때문에 어딘가에서 계속 쓰이고 있는 한 nil이 되어버릴 일은 없다.


- viewDidLoad와 viewDidAppear의 차이점은 무엇입니까? 원격 서버에서 데이터를 로드하여 View에 표시하려면 어느 것을 사용해야합니까?
viewDidLoad는 메모리에 로드가 끝났을 때 호출된다. 그렇기 때문에 한번 호출되고 끝이다.
viewDidAppear은 보여질 때만다 호출된다. 백그라운드에서 포그라운드로 올때도 호출되고 화면 전환하고 다시 돌아올 때도 호출된다.
데이터가 실시간으로 변경되는 것이라면, 뷰가 나타날 때마다 업데이트 할 수 있게 viewDidAppear 넣는게 좋다.


- 싱글 톤에 대해 압니까? 어느 경우에서 싱글 톤을 사용하고 어떨때 사용하지 않을 것입니까?
인스턴스를 단 한번만 생성할 수 있는 디자인패턴을 말한다.
보통 어플리케이션 전반에 걸처서 중복으로 인스턴스를 생성하지 않고 단 한번의 생성으로 같은 인스턴스를 공유하여 사용할 때 이용한다.
인스턴스를 여러개 생성하여 독립적으로 운영시킬 때는 사용하면 안된다.
IOCare에서는 SharedData라는 클래스를 싱글톤으로 만들어서 어플리케이션 전반에 걸쳐서 데이터들을 공유한다.


- 블록이란 무엇이며 어떻게 사용됩니까?
런타임에서 생성되는 동적 함수이다.
함수를 따로 정의하지 않고도 동적으로 코드를 동작시킬 수 있다.
보통은 따로 메서드를 정의하지 않고 익명함수로 간단하게 동작시킬 때 사용된다.
__block int x = 3;
Int (^printXAndY)(int) = ^(int y) {
    x = x + y;
    return x;
};
NSLog(@“x = %@”, printXAndY);


- iOS가 멀티 스레딩을 지원하기 위해 제공하는 메커니즘은 무엇입니까?
GCD(Grand Central Dispatch)가 있다.
GCD를 이용하면 멀티코어 프로세서에 최적환 된 어플리케이션을 만들 수 있어 애플에서 사용하기를 권장하고 있다.
dispatch_queue_t serialQueue = dispatch_queue_create("testQ”, DISPATCH_QUEUE_SERIAL);
dispatch_async(serialQueue, ^{ NSLog(@"Call 1"); });
이런식으로 스레드 큐를 만들어서 따로 작업시킬 스레드를 넣고 실행시킬 수 있다.
순차적으로 할건지, 몇 초후에 실행시킬 건지, 메인스레드 큐에다 넣을건지, 특정 스레드가 끝나면 콜백을 받을 건지 등을 조작 할 수도 있다.


- 카테고리 란 무엇이며 언제 사용됩니까?
기능 확대가 필요할 때 사용된다.
IOCare에서는 AppDelegate에 푸시기능을 추가하거나
NSString, NSDictionary, NSLayoutConstraint 등에 필요한 기능을 추가시킬 때 사용되었다.
카테고리 이름 명명 방식은 “해당소스파일 이름 + 추가한 기능” 이런식으로 사용된다.